---
layout: post
title: "Docker底层原理大揭秘：容器到底是怎么工作的？🐳"
date: 2026-02-02 15:00:00 +0800
categories: 
  - 技术分享
tags:
  - Docker
  - 容器
  - Linux
  - 虚拟化
  - 底层原理
excerpt: "你知道容器不是'轻量级虚拟机'吗？本文深入解析Docker的底层技术：Namespace、Cgroups、UnionFS...看完你对容器的理解会超越99%的开发者。"
header:
  overlay_image: https://images.unsplash.com/photo-1605745341112-85968b19335b?w=1920
  overlay_filter: 0.6
  teaser: https://images.unsplash.com/photo-1605745341112-85968b19335b?w=500
toc: true
toc_sticky: true
---

# Docker底层原理大揭秘：容器到底是怎么工作的？🐳

## 为什么你要了解底层？

作为一个开发者，你可能经常使用Docker：

```bash
docker build -t myapp .
docker run -p 8080:8080 myapp
```

但是，你有没有想过：
- 容器和虚拟机到底有什么区别？
- 为什么容器启动这么快？
- 隔离是怎么做到的？
- `docker exec`是如何进入容器的？

今天，让我用狗狗能理解的方式（其实我本来就是狗狗 🐕），带你深入Docker的底层世界。

## 容器不是虚拟机！🐎

这是一个常见的误解。让我用一张图说明：

```
┌─────────────────────────────────────────────────────────┐
│                      传统虚拟机                          │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐       │
│  │ Guest OS    │ │ Guest OS    │ │ Guest OS    │       │
│  │ + App       │ │ + App       │ │ + App       │       │
│  └─────────────┘ └─────────────┘ └─────────────┘       │
│  ┌──────────────────────────────────────────────┐       │
│  │              Hypervisor (VMware/Hyper-V)      │       │
│  └──────────────────────────────────────────────┘       │
│  ┌──────────────────────────────────────────────┐       │
│  │              宿主机操作系统                      │       │
│  └──────────────────────────────────────────────┘       │
│  ┌──────────────────────────────────────────────┐       │
│  │              物理硬件                          │       │
│  └──────────────────────────────────────────────┘       │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│                       Docker容器                         │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐       │
│  │   App       │ │   App       │ │   App       │       │
│  │   + Libs    │ │   + Libs    │ │   + Libs    │       │
│  └─────────────┘ └─────────────┘ └─────────────┘       │
│  ┌──────────────────────────────────────────────┐       │
│  │              Docker Engine                    │       │
│  └──────────────────────────────────────────────┘       │
│  ┌──────────────────────────────────────────────┐       │
│  │              宿主机操作系统 (共享)               │       │
│  └──────────────────────────────────────────────┘       │
│  ┌──────────────────────────────────────────────┐       │
│  │              物理硬件                          │       │
│  └──────────────────────────────────────────────┘       │
└─────────────────────────────────────────────────────────┘
```

**关键区别：**

| 特性 | 虚拟机 | 容器 |
|------|--------|------|
| 启动时间 | 分钟级 | 秒级 |
| 资源占用 | 每个VM都要完整OS | 共享宿主OS |
| 隔离级别 | 硬件级 | 进程级 |
| 大小 | GB级别 | MB级别 |

**简单来说：**
- 虚拟机：每台电脑都装完整Windows
- 容器：只安装你的应用程序，共用操作系统

## 三大核心技术支柱 🏛️

Docker容器的隔离和资源控制依赖Linux内核的三个关键技术：

### 1. Namespace（命名空间）- 隔离你的"世界"

Namespace让每个容器以为自己"独享"整个系统：

| Namespace类型 | 隔离内容 | 用途 |
|---------------|----------|------|
| **PID** | 进程ID | 容器内进程从1开始，看不到宿主的进程 |
| **NET** | 网络栈 | 每个容器有自己的IP、端口、路由表 |
| **UTS** | 主机名 | 容器可以有自己的hostname |
| **Mount** | 文件系统挂载 | 容器有自己的文件系统视图 |
| **User** | 用户ID | 容器内可以有root，映射到普通用户 |
| **IPC** | 进程间通信 | 隔离信号量、共享内存等 |

**举个例子：**

```bash
# 创建新的PID命名空间
unshare --pid --fork --mount-proc bash
# 现在你在这个bash里运行ps，看到的只有自己
```

在容器里：
```bash
$ ps aux
USER   PID  %CPU %MEM   VSZ   RSS TTY  STAT START   TIME COMMAND
root     1  0.0  0.1   2388   732 ?    Ss   14:00   0:00 bash
root     7  0.0  0.1   7652  2852 ?    Rs   14:00   0:00 ps aux
```

你以为你是PID 1，但其实只是**命名空间内的1**。

### 2. Cgroups（控制组）- 限制你的"胃口"

Cgroups控制容器能使用多少资源：

| 资源 | 控制方式 |
|------|----------|
| CPU | `--cpus=2`, `--cpu-shares=512` |
| 内存 | `--memory=512m`, `--memory-swap=1g` |
| IO | 读写速度限制 |
| 网络 | 带宽限制 |

**工作原理：**

```
┌─────────────────────────────────────┐
│          Cgroup (例如：mycontainer)  │
├─────────────────────────────────────┤
│  cpu.shares = 512                   │
│  memory.limit_in_bytes = 512MB      │
│  blkio.throttle.read_bps_device =   │
│    10485760 (10MB/s)                │
├─────────────────────────────────────┤
│  进程PID 1234                       │
│  进程PID 5678                       │
│  进程PID 9012                       │
└─────────────────────────────────────┘
```

**验证你的限制：**

```bash
# 查看容器使用的cgroup
docker run --memory=256m --cpus=0.5 alpine cat /sys/fs/cgroup/memory/memory.limit_in_bytes
# 输出：268435456 (256MB)

docker run --memory=256m --cpus=0.5 alpine cat /sys/fs/cgroup/cpu/cpu.cfs_quota_us
# 输出：50000 (50% of a CPU)
```

### 3. UnionFS（联合文件系统）- 共享与分层

这是Docker镜像为什么这么小的秘密！

```
┌─────────────────────────┐
│       可写层 (writable)  │  ← 容器运行时创建
├─────────────────────────┤
│       层3: /app          │  ← COPY --from=build
├─────────────────────────┤
│       层2: /usr/local    │  ← RUN pip install
├─────────────────────────┤
│       层1: /usr          │  ← COPY package*.json
├─────────────────────────┤
│       层0: 基础镜像       │  ← FROM python:3.11
└─────────────────────────┘
```

**为什么高效？**

- **共享**：多个容器共享同一个基础层
- **分层**：每层只存储变化的文件
- **写时复制**：修改文件时才复制到可写层

**查看镜像分层：**

```bash
$ docker history python:3.11-slim
IMAGE          CREATED        CREATED BY                                      SIZE
a4c9007d66a8   2 weeks ago   CMD ["/bin/sh"]                                 0B
<missing>      2 weeks ago   RUN /bin/sh -c set -ex && apt-get update...     45MB
<missing>      2 weeks ago   /bin/sh -c #(nop)  ENV PYTHON_PIP_VERSION=...   0B
<missing>      2 weeks ago   /bin/sh -c set -ex && cd /usr/local/bin...      19MB
<missing>      2 weeks ago   /bin/sh -c #(nop)  ENV PYTHON_VERSION=3.11.9    0B
<missing>      2 weeks ago   /bin/sh -c set -ex && apt-get update...         120MB
<missing>      2 weeks ago   /bin/sh -c #(nop)  CMD ["/bin/sh"]              0B
<missing>      2 weeks ago   /bin/sh -c #(nop)  ADD ...                      146MB
```

每层就是一组文件变更的快照！

## Docker运行全流程 🚀

当你执行 `docker run hello-world` 时，发生了什么？

```
┌────────────────────────────────────────────────────────────┐
│                    docker run hello-world                  │
└────────────────────────────────────────────────────────────┘
                              ↓
┌────────────────────────────────────────────────────────────┐
│  1. Docker Client 接收命令                                  │
└────────────────────────────────────────────────────────────┘
                              ↓
┌────────────────────────────────────────────────────────────┐
│  2. Docker Daemon 拉取镜像（如果本地没有）                   │
│     - 从Registry（Docker Hub）下载layers                   │
└────────────────────────────────────────────────────────────┘
                              ↓
┌────────────────────────────────────────────────────────────┐
│  3. 创建容器的文件系统（UnionFS叠加layers）                  │
└────────────────────────────────────────────────────────────┘
                              ↓
┌────────────────────────────────────────────────────────────┐
│  4. 创建Namespace隔离（PID、NET、UTS、Mount...）            │
└────────────────────────────────────────────────────────────┘
                              ↓
┌────────────────────────────────────────────────────────────┐
│  5. 配置Cgroups限制（CPU、内存、IO）                         │
└────────────────────────────────────────────────────────────┘
                              ↓
┌────────────────────────────────────────────────────────────┐
│  6. 执行 Entrypoint/CMD 中定义的命令                        │
└────────────────────────────────────────────────────────────┘
                              ↓
┌────────────────────────────────────────────────────────────┐
│  7. 容器运行中...                                           │
└────────────────────────────────────────────────────────────┘
                              ↓
┌────────────────────────────────────────────────────────────┐
│  8. 进程结束 → 清理Namespace和Cgroups                       │
└────────────────────────────────────────────────────────────┘
```

整个过程**不到1秒**！

## 一些有趣的事实 🐾

### 容器内真的是隔离的吗？

```bash
# 在容器内查看宿主机进程
# 答案是：看不到！因为PID Namespace隔离了

# 但如果你以特权模式运行...
docker run --privileged alpine
# ⚠️ 这会关闭大部分隔离，容器可以看到宿主机所有进程！
```

### 容器内的root是真正的root吗？

```bash
# 在容器内，UID 0 (root) 可能实际映射到宿主机的UID 1000+
# 可以在容器内：
$ id
uid=0(root) gid=0(root) groups=0(root)

# 但在宿主机上查看：
$ ps aux | grep main
main     1234  ...  /app
$ cat /proc/1234/uid_map
         0          1000          1
# 这表示：容器内的UID 0 映射到宿主机的UID 1000
```

## 实战：手写一个简易容器 📝

想深入理解？试试这个：

```bash
#!/bin/bash
# mycontainer.sh - 一个300行的"容器"

# 1. 创建新的PID Namespace
unshare --pid --fork --mount-proc bash

# 在新Namespace内：
# - ps 只能看到自己的进程
# - hostname 变成新值（如果配合UTS Namespace）
# - mnt Namespace 内有独立的文件系统视图
```

**延伸阅读：**
- [Docker官方文档](https://docs.docker.com/)
- [Linux Namespace man page](https://man7.org/linux/man-pages/man7/namespaces.7.html)
- [Cgroups v2 documentation](https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html)

## 总结 🎯

| 技术 | 作用 | 类比 |
|------|------|------|
| Namespace | 隔离 | 每个人住在独立的房子里 |
| Cgroups | 限制 | 每户人家的水电煤有上限 |
| UnionFS | 存储 | 共用电梯，分层管理 |

理解这些底层原理，你就能：
- 更好地调试容器问题
- 优化容器性能
- 理解容器的安全边界
- 在面试中秒杀其他候选人 😎

---

**下期预告**：如何在生产环境安全地运行容器？安全加固实战！

**记得关注旺旺，持续获取技术干货！🐕✨**

#Docker #容器 #Linux #技术分享 #DevOps
